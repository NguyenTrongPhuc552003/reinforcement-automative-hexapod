/'
 * Hexapod Project - A Reinforcement Learning-based Autonomous Hexapod
 * Copyright (C) 2025  Nguyen Trong Phuc
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 '/

@startuml class
!theme plain
!define RECTANGLE class

title <font size=20><b>Hexapod Robot - Class Diagram</b></font>
left header Version 1.0 - Reinforcement Learning Autonomous Hexapod
right header BeagleBone Black Platform

skinparam class {
    BackgroundColor<<Actuators>> #D1C4E9
    BackgroundColor<<PIMPL>> #FFB74D
    BackgroundColor<<Singleton>> #FFF9C4
    BackgroundColor<<Utilities>> #B3E5FC
    BackgroundColor<<Hardware>> #C8E6C9
    BackgroundColor<<Controller>> #FFCDD2
}

skinparam package {
    BackgroundColor #E1F5FE
    BorderColor #666666
}

package "Hardware Layer" {
    class Hexapod <<Hardware>> {
        -pImpl: unique_ptr<HexapodImpl>
        +init(): bool
        +cleanup(): void
        +setLegPosition(leg_num: uint8_t, position: LegPosition): bool
        +getLegPosition(leg_num: uint8_t, position: LegPosition&): bool
        +getImuData(data: ImuData&): bool
        +setSensorType(type: SensorType): bool
        +getSensorType(type: SensorType&): bool
        +setCalibration(leg_num: uint8_t, hip: int16_t, knee: int16_t, ankle: int16_t): bool
        +centerAll(): bool
        +getLastError(): ErrorInfo
        +getCurrentTime(): double
    }

    class HexapodImpl <<PIMPL>> {
        -fd: int
        -initialized: bool
        -leg_positions: LegPosition[6]
        -imu_data: ImuData
        -lastError: ErrorInfo
        +executeIoctl(request: unsigned long, arg: void*): bool
        +setError(code: int, category: ErrorCategory, message: string): void
    }

    class LegPosition {
        +leg_num: uint8_t
        +joints: JointAngles
        +getHip(): int16_t
        +getKnee(): int16_t
        +getAnkle(): int16_t
        +setHip(value: int16_t): void
        +setKnee(value: int16_t): void
        +setAnkle(value: int16_t): void
    }

    struct JointAngles {
        +hip: int16_t
        +knee: int16_t
        +ankle: int16_t
    }

    class ImuData {
        +accel_x: int16_t
        +accel_y: int16_t
        +accel_z: int16_t
        +gyro_x: int16_t
        +gyro_y: int16_t
        +gyro_z: int16_t
        +sensor_type: uint8_t
        +getAccelX(): float
        +getAccelY(): float
        +getAccelZ(): float
        +getGyroX(): float
        +getGyroY(): float
        +getGyroZ(): float
        +hasGyro(): bool
        +getSensorType(): SensorType
    }

    enum SensorType {
        MPU6050
        ADXL345
        AUTO
    }

    class UltrasonicSensor <<Hardware>> {
        -pImpl: unique_ptr<Impl>
        +init(): bool
        +cleanup(): void
        +measure(): Measurement
        +measureAverage(samples: int): Measurement
        +isObjectDetected(maxRange: float): bool
        +selfTest(): bool
        +getConfig(): SensorConfig
        +setConfig(config: SensorConfig): void
    }

    struct UltrasonicSensor::Measurement {
        +distance: float
        +valid: bool
        +timestamp: time_point
        +rawDistance: float
        +echoTimeUs: int
    }
}

package "Motion Control Layer" {
    class Kinematics <<Singleton>> {
        -pImpl: unique_ptr<KinematicsImpl>
        +{static}getInstance(): Kinematics&
        +forwardKinematics(angles: LegPosition&, position: Point3D&): bool
        +inverseKinematics(position: Point3D&, angles: LegPosition&): bool
        +isPositionReachable(position: Point3D&): bool
        +setLegParameters(legIndex: int, coxa: double, femur: double, tibia: double): bool
    }

    class KinematicsImpl <<PIMPL>> {
        -initialized: bool
        -legParams: array<LegParameters, 6>
        +setLegParameters(legIndex: int, coxa: double, femur: double, tibia: double): bool
    }

    class Point3D {
        +x: double
        +y: double
        +z: double
        +Point3D(x: double, y: double, z: double)
        +operator+(other: Point3D): Point3D
        +operator-(other: Point3D): Point3D
        +operator*(scalar: double): Point3D
        +length(): double
        +normalize(): void
        +distanceTo(other: Point3D): double
        +{static}lerp(a: Point3D, b: Point3D, t: double): Point3D
        +{static}dot(a: Point3D, b: Point3D): double
        +{static}cross(a: Point3D, b: Point3D): Point3D
    }

    class Gait {
        -pImpl: unique_ptr<GaitImpl>
        +init(hexapod: Hexapod&, params: GaitParameters): bool
        +update(time: double, direction: double, speed: double): bool
        +centerLegs(): bool
        +getParameters(): GaitParameters
        +setParameters(params: GaitParameters): bool
        +calculateLegPhase(legIndex: int, time: double): double
        +isInitialized(): bool
    }

    class GaitImpl <<PIMPL>> {
        -hexapod: Hexapod&
        -params: GaitParameters
        -initialized: bool
        -defaultPositions: vector<Position>
        -phaseOffsets: vector<double>
        -legStates: vector<int>
        +updateLegPosition(legIndex: int, phase: double, direction: double, speed: double): bool
        +computeLegTrajectory(position: Point3D&, phase: double, direction: double, speed: double): void
    }

    class GaitParameters {
        +type: GaitType
        +stepHeight: double
        +stepLength: double
        +cycleTime: double
        +dutyFactor: double
        +validate(): bool
    }

    enum GaitType {
        TRIPOD
        WAVE
        RIPPLE
    }
}

package "Control Layer" {
    class Controller <<Controller>> {
        -pImpl: unique_ptr<ControllerImpl>
        +Controller(hexapod: Hexapod&)
        +init(): bool
        +processKey(key: char): bool
        +update(): bool
        +getState(): ControllerState
        +setSpeed(speed: double): void
        +setDirection(direction: double): void
        +setHeight(height: double): void
        +setTilt(tiltX: double, tiltY: double): void
        +setGaitType(type: GaitType): void
        +setBalanceEnabled(enabled: bool): void
        +isBalanceEnabled(): bool
        +switchImuSensor(sensorType: SensorType): void
        +getCurrentImuSensor(): SensorType
        +validateServoMapping(): bool
        +testServoConnectivity(): bool
    }

    class ControllerImpl <<PIMPL>> {
        -hexapod: Hexapod&
        -gait: Gait
        -speed: double
        -direction: double
        -height: double
        -tiltX: double
        -tiltY: double
        -state: ControllerState
        -balanceConfig: BalanceConfig
        -ultrasonicSensor: unique_ptr<UltrasonicSensor>
        -currentSensorType: SensorType
        +applyTilt(): bool
        +processBalanceAdjustments(): bool
        +calculateTilt(imuData: ImuData&, roll: double&, pitch: double&): void
        +readUltrasonicDistance(): double
        +processObstacleAvoidance(distance: double): bool
    }

    enum ControllerState {
        IDLE
        WALKING
        ROTATING
        TILTING
    }

    struct BalanceConfig {
        +max_tilt_adjustment: double
        +response_factor: double
        +deadzone: double
        +enabled: bool
    }
}

package "Central Pattern Generator (CPG)" {
    class "cpg::Controller" <<Controller>> {
        -pImpl: unique_ptr<ControllerImpl>
        +Controller()
        +~Controller()
        +initialize(config: ControllerConfig): bool
        +shutdown(): void
        +executeCommand(command: LocomotionCommand): bool
        +startLocomotion(): bool
        +stopLocomotion(): bool
        +updateBalanceFeedback(imuData: ImuData): void
        +handleAutonomousMode(): bool
        +getControllerState(): ControllerState
        +getCurrentGait(): string
        +isActive(): bool
        +getOutputs(): vector<LegOutput>
        +enableAutonomousNavigation(enable: bool): void
        +processObstacleAvoidance(): bool
    }

    class "cpg::Network" <<PIMPL>> {
        -pImpl: unique_ptr<NetworkImpl>
        +Network(networkParams: NetworkParams, gaitParams: GaitParams)
        +~Network()
        +initialize(numOscillators: size_t, gaitType: string): bool
        +configureForHexapod(gaitType: string): bool
        +addOscillator(params: OscillatorParams): size_t
        +removeOscillator(id: size_t): bool
        +addCoupling(from: size_t, to: size_t, params: CouplingParams): bool
        +removeCoupling(from: size_t, to: size_t): bool
        +update(dt: double): bool
        +reset(randomPhases: bool): void
        +getNetworkState(): NetworkState
        +getNetworkOutput(): NetworkOutput
        +getRawOutputs(): vector<double>
        +getPhaseOutputs(): vector<double>
        +getStancePhases(): vector<bool>
        +switchGait(gaitType: string): bool
        +setGlobalFrequency(scale: double): bool
        +isSynchronized(tolerance: double): bool
        +isStable(): bool
        +validateConfiguration(): bool
    }

    class "cpg::Oscillator" <<PIMPL>> {
        -pImpl: unique_ptr<OscillatorImpl>
        +Oscillator(id: size_t, params: OscillatorParams)
        +~Oscillator()
        +update(dt: double, couplingInput: double): bool
        +reset(randomPhase: bool): void
        +getId(): size_t
        +setParameters(params: OscillatorParams): bool
        +getParameters(): OscillatorParams
        +getState(): OscillatorState
        +setState(state: OscillatorState): bool
        +getOutput(): OscillatorOutput
        +getRawOutput(): double
        +getScaledOutput(): double
        +getPhaseOutput(): double
        +getPhase(): double
        +setPhase(phase: double): bool
        +getFrequency(): double
        +setFrequency(frequency: double): bool
        +getAmplitude(): double
        +setAmplitude(amplitude: double): bool
        +isStancePhase(): bool
        +getStanceProgress(): double
        +getSwingProgress(): double
        +addCouplingInput(strength: double, phaseDiff: double, weight: double): void
        +clearCouplingInputs(): void
        +getTotalCouplingInput(): double
        +validateState(): bool
        +isStable(): bool
    }

    class "cpg::Parameters" <<PIMPL>> {
        -pImpl: unique_ptr<ParametersImpl>
        +Parameters()
        +~Parameters()
        +loadFromFile(filename: string): bool
        +saveToFile(filename: string): bool
        +getOscillatorParams(gaitType: string, legId: size_t): OscillatorParams
        +getCouplingParams(from: size_t, to: size_t): CouplingParams
        +getGaitParams(gaitType: string): GaitParams
        +getNetworkParams(): NetworkParams
        +setOscillatorParams(gaitType: string, legId: size_t, params: OscillatorParams): void
        +setCouplingParams(from: size_t, to: size_t, params: CouplingParams): void
        +setGaitParams(gaitType: string, params: GaitParams): void
        +setNetworkParams(params: NetworkParams): void
        +validateAll(): bool
        +reset(): void
    }

    struct "cpg::OscillatorParams" {
        +frequency: double
        +amplitude: double
        +phase: double
        +offset: double
        +duty_cycle: double
        +OscillatorParams()
        +OscillatorParams(freq: double, amp: double, ph: double, off: double, duty: double)
    }

    struct "cpg::CouplingParams" {
        +strength: double
        +phase_offset: double
        +weight: double
        +coupling_type: string
        +is_symmetric: bool
        +CouplingParams()
        +CouplingParams(str: double, phase: double, w: double)
    }

    struct "cpg::GaitParams" {
        +gait_type: string
        +step_frequency: double
        +step_height: double
        +duty_factor: double
        +stance_duration: double
        +swing_duration: double
        +coupling_strength: double
        +phase_offsets: vector<double>
        +GaitParams()
        +GaitParams(type: string, freq: double, height: double, duty: double)
    }

    struct "cpg::NetworkParams" {
        +num_oscillators: size_t
        +update_frequency: double
        +global_frequency_scale: double
        +synchronization_threshold: double
        +stability_threshold: double
        +max_coupling_strength: double
        +NetworkParams()
    }

    struct "cpg::OscillatorState" {
        +x: double
        +y: double
        +phase: double
        +amplitude: double
        +frequency: double
        +OscillatorState()
        +OscillatorState(x_val: double, y_val: double, ph: double, amp: double, freq: double)
    }

    struct "cpg::OscillatorOutput" {
        +raw_output: double
        +scaled_output: double
        +phase_output: double
        +is_stance_phase: bool
        +OscillatorOutput()
    }

    struct "cpg::NetworkState" {
        +oscillator_states: vector<OscillatorState>
        +network_time: double
        +global_frequency: double
        +is_synchronized: bool
        +NetworkState()
    }

    struct "cpg::NetworkOutput" {
        +joint_positions: vector<double>
        +joint_velocities: vector<double>
        +stance_phases: vector<bool>
        +gait_progress: vector<double>
        +step_frequency: double
        +is_stable: bool
        +NetworkOutput()
    }

    struct "cpg::ConnectionTopology" {
        +from_oscillator: size_t
        +to_oscillator: size_t
        +coupling: CouplingParams
        +is_active: bool
        +ConnectionTopology()
        +ConnectionTopology(from: size_t, to: size_t, params: CouplingParams)
    }

    class "cpg::oscillator_utils" <<Utilities>> {
        +normalizePhase(phase: double): double
        +phaseDifference(phase1: double, phase2: double): double
        +phaseToGaitProgress(phase: double, dutyCycle: double): double
        +isStancePhase(phase: double, dutyCycle: double): bool
        +validateParameters(params: OscillatorParams): bool
        +createGaitParameters(gaitType: string, legId: size_t): OscillatorParams
    }

    class "cpg::network_utils" <<Utilities>> {
        +validateGaitType(gaitType: string): bool
        +createDefaultCouplingMatrix(gaitType: string): vector<vector<double>>
        +cpgToJointAngle(cpgOutputs: vector<double>, legId: size_t, jointId: size_t): double
        +computeSynchronizationIndex(phases: vector<double>): double
        +generateHexapodCouplingMatrix(couplingStrength: double): vector<vector<double>>
    }
}

package "Application Layer" {
    class Application <<Singleton>> {
        -pImpl: unique_ptr<ApplicationImpl>
        +{static}getInstance(): Application&
        +{static}m_running: atomic<bool>
        +{static}m_telemetryActive: atomic<bool>
        +init(): bool
        +run(): ExecutionResult
        +shutdown(): void
        +switchMode(mode: ControlMode): bool
        +getCurrentMode(): ControlMode
        +getLastErrorMessage(): string
        +{static}signalHandler(signal: int): void
    }

    class ApplicationImpl <<PIMPL>> {
        -currentMode: ControlMode
        -hexapod: unique_ptr<Hexapod>
        -controller: unique_ptr<cpg::Controller>
        -legacyController: unique_ptr<Controller>
        -keyCommands: unordered_map<char, KeyCommand>
        -frameCount: unsigned long
        -totalFrameTime: unsigned long
        -maxFrameTime: unsigned long
        +initializeHexapod(): bool
        +initializeController(): bool
        +setupInputHandling(): bool
        +setupKeyCommands(): void
        +processInput(): bool
        +update(): bool
        +displayTelemetry(): void
        +reportPerformance(): void
    }

    enum ControlMode {
        MANUAL
        AUTONOMOUS
        SEQUENCE
        CALIBRATION
    }

    enum ExecutionResult {
        SUCCESS
        ERROR_INITIALIZATION
        ERROR_RUNTIME
        ERROR_SHUTDOWN
        TERMINATED_BY_USER
    }
}

package "Calibration System" {
    class CalibrationManager <<Singleton>> {
        -pImpl: unique_ptr<CalibrationManagerImpl>
        +{static}getInstance(): CalibrationManager&
        +{static}loadCalibration(calibrations: vector<Calibration>&, filename: string): bool
        +{static}saveCalibration(calibrations: vector<Calibration>&, filename: string): bool
        +{static}getDefaultCalibration(): vector<Calibration>
        +{static}applyCalibration(hexapod: Hexapod&, calibrations: vector<Calibration>&): bool
        +{static}validateCalibration(calibrations: vector<Calibration>&): bool
        +{static}getDefaultCalibrationPath(): string
    }

    struct Calibration {
        +leg_num: uint8_t
        +hip_offset: int16_t
        +knee_offset: int16_t
        +ankle_offset: int16_t
        +Calibration()
        +Calibration(leg: uint8_t, hip: int16_t, knee: int16_t, ankle: int16_t)
    }

    class CalibrationException {
        -message: string
        +CalibrationException(message: string)
        +what(): const char*
    }
}

package "Common Utilities" <<Utilities>> {
    class TerminalManager {
        +{static}setupNonBlocking(): bool
        +{static}setupImmediate(): bool
        +{static}restore(): void
        +{static}isModified(): bool
        +{static}readChar(ch: char&): bool
    }

    class SignalManager {
        +{static}setupGracefulShutdown(running: atomic<bool>&, handler: SignalHandler): void
        +{static}defaultHandler(signal: int): void
    }

    class PerformanceMonitor {
        -frameStart: time_point
        -frameCount: unsigned long
        -totalFrameTime: double
        -maxFrameTime: double
        +startFrame(): void
        +endFrame(): void
        +getAverageFrameTime(): double
        +getFPS(): double
        +reset(): void
        +printReport(prefix: string): void
    }

    class ErrorReporter {
        +{static}reportError(component: string, operation: string, details: string): void
        +{static}reportWarning(component: string, message: string): void
        +{static}reportInfo(component: string, message: string): void
    }

    class Validator {
        +{static}validateAngle(angle: double, min: double, max: double): bool
        +{static}validateLegNumber(legNum: int, maxLegs: int): bool
        +{static}validateSpeed(speed: double): bool
        +{static}clamp<T>(value: T, min: T, max: T): T
    }

    class StringUtils {
        +{static}formatNumber(value: double, precision: int): string
        +{static}formatDuration(seconds: double): string
        +{static}padString(text: string, width: int, fillChar: char): string
        +{static}toLower(str: string): string
        +{static}toUpper(str: string): string
    }

    class MathUtils {
        +{static}degToRad(degrees: double): double
        +{static}radToDeg(radians: double): double
        +{static}lerp(a: double, b: double, t: double): double
        +{static}normalizeAngle(angle: double): double
        +{static}movingAverage(values: vector<double>, windowSize: int): vector<double>
    }
}

' Relationships
Hexapod ||--|| HexapodImpl : pImpl
Hexapod "1" *-- "6" LegPosition : manages
LegPosition *-- JointAngles
Hexapod "1" *-- "1" ImuData : reads
ImuData -- SensorType

Kinematics ||--|| KinematicsImpl : pImpl
Kinematics ..> Point3D : uses
Kinematics ..> LegPosition : transforms

Gait ||--|| GaitImpl : pImpl
GaitImpl --> Hexapod : controls
Gait "1" *-- "1" GaitParameters : configured_by
GaitParameters -- GaitType

Controller ||--|| ControllerImpl : pImpl
ControllerImpl --> Hexapod : controls
ControllerImpl "1" *-- "1" Gait : uses
ControllerImpl "1" *-- "1" UltrasonicSensor : optional
ControllerImpl "1" *-- "1" BalanceConfig : configured_by
ControllerImpl -- ControllerState

' CPG System Relationships
cpg::Controller "1" *-- "1" cpg::Network : manages
cpg::Controller "1" *-- "1" cpg::Parameters : uses
cpg::Controller --> Hexapod : controls
cpg::Controller ..> ImuData : processes

cpg::Network "1" *-- "6" cpg::Oscillator : contains
cpg::Network "1" *-- "*" cpg::ConnectionTopology : manages
cpg::Network ..> cpg::NetworkState : produces
cpg::Network ..> cpg::NetworkOutput : generates

cpg::Oscillator "1" *-- "1" cpg::OscillatorState : maintains
cpg::Oscillator "1" *-- "1" cpg::OscillatorParams : configured_by
cpg::Oscillator ..> cpg::OscillatorOutput : generates

cpg::Parameters "1" *-- "*" cpg::GaitParams : manages
cpg::Parameters "1" *-- "*" cpg::OscillatorParams : manages
cpg::Parameters "1" *-- "*" cpg::CouplingParams : manages
cpg::Parameters "1" *-- "1" cpg::NetworkParams : manages

cpg::ConnectionTopology "1" *-- "1" cpg::CouplingParams : configured_by

' Enhanced Application Relationships
ApplicationImpl "1" *-- "1" cpg::Controller : primary_controller
ApplicationImpl "1" *-- "1" Controller : legacy_support
ApplicationImpl --> cpg::oscillator_utils : uses
ApplicationImpl --> cpg::network_utils : uses

Application ||--|| ApplicationImpl : pImpl
ApplicationImpl "1" *-- "1" Hexapod : manages
ApplicationImpl "1" *-- "1" cpg::Controller : uses
ApplicationImpl "1" *-- "1" Controller : legacy_support
Application -- ControlMode
Application -- ExecutionResult

CalibrationManager "1" *-- "*" Calibration : manages
CalibrationManager ..> Hexapod : configures
CalibrationManager ..> CalibrationException : throws

UltrasonicSensor "1" *-- "1" UltrasonicSensor::Measurement : produces

' Constants and Configuration
note top of Hexapod : Hardware Bus:\nI2C Bus 2 on BeagleBone Black\nSCL: P9_19, SDA: P9_20, 100kHz\n\nPhysical Organization:\n- 6 legs with 3 servos each\n- 2 PWM controllers (primary/secondary)\n- 1 IMU for orientation sensing

legend right
  <b>Hexapod Robot - Class Legend</b>
  --
  <back:#E6CCFF>■</back> Actuators
  <back:#FF7700>■</back> Implementation Classes (PIMPL)
  <back:#FFE6CC>■</back> Singleton Pattern
  <back:#E6F3FF>■</back> Utility Classes
  <back:#E6FFE6>■</back> Hardware Interface
  <back:#FFE6E6>■</back> Control Layer
  
  <b>Hardware Bus:</b>
  I2C Bus 2 on BeagleBone Black
  SCL: P9_19, SDA: P9_20, 100kHz
  
  <b>Physical Organization:</b>
  - 6 legs with 3 servos each
  - 2 PWM controllers (primary/secondary)
  - 1 IMU for orientation sensing
endlegend

@enduml
